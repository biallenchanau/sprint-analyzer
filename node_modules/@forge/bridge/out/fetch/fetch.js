"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.productFetchApi = void 0;
const tslib_1 = require("tslib");
const parseBodyAndHeaders = (init) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const req = new Request('', { body: init === null || init === void 0 ? void 0 : init.body, method: init === null || init === void 0 ? void 0 : init.method, headers: init === null || init === void 0 ? void 0 : init.headers });
    const body = req.method !== 'GET' ? yield req.text() : null;
    const headers = Object.fromEntries(req.headers.entries());
    return {
        body,
        headers: new Headers(headers)
    };
});
exports.productFetchApi = (callBridge) => {
    const fetch = (product, restPath, init) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const { body: requestBody, headers: requestHeaders } = yield parseBodyAndHeaders(init);
        if (!requestHeaders.has('X-Atlassian-Token')) {
            requestHeaders.set('X-Atlassian-Token', 'no-check');
        }
        const fetchPayload = {
            product,
            restPath,
            fetchRequestInit: Object.assign(Object.assign({}, init), { body: requestBody, headers: [...requestHeaders.entries()] })
        };
        const { body, headers, statusText, status } = yield callBridge('fetchProduct', fetchPayload);
        return new Response(body || null, { headers, status, statusText });
    });
    return {
        requestConfluence: (restPath, fetchOptions) => fetch('confluence', restPath, fetchOptions),
        requestJira: (restPath, fetchOptions) => fetch('jira', restPath, fetchOptions)
    };
};
